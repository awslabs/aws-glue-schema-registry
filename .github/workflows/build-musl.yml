name: Build Musl

on:
  push:
    branches: [ master, native-schema-registry-release ]
  pull_request:
    branches: [ master, native-schema-registry-release ]
  release:
    branches: [ master, native-schema-registry-release ]
    types: [ created ]

jobs:
  build-musl:
    continue-on-error: false
    timeout-minutes: 90
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
        
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        
      - name: Build GraalVM musl container
        run: |
          cd native-schema-registry/musl-build-helper-scripts/musl
          docker build -f Dockerfile.graalvm -t native-graalvm .
          
      - name: Build CMake musl container  
        run: |
          cd native-schema-registry/musl-build-helper-scripts/musl
          docker build -f Dockerfile.cmake -t native-cmake .

      - name: Clean previous builds
        run: |
          rm -rf native-schema-registry/c/build
          
      - name: Build Java components with musl
        run: |
          cd native-schema-registry/musl-build-helper-scripts/musl
          HOST_SOURCE_DIR="$(realpath ../../..)"
          SCRIPT_PATH="$(realpath ./build-musl-inner.sh)"
          CONTAINER_WORKDIR="/workspace"
          
          docker run --rm \
            --entrypoint /bin/sh \
            -v "$HOST_SOURCE_DIR":"$CONTAINER_WORKDIR" \
            -v "$SCRIPT_PATH":/tmp/musl-build-inner.sh \
            -w "$CONTAINER_WORKDIR" \
            "native-graalvm" \
            /tmp/musl-build-inner.sh

      - name: Build C components with musl
        run: |
          cd native-schema-registry/musl-build-helper-scripts/musl  
          HOST_SOURCE_DIR="$(realpath ../../..)"
          CMAKE_SCRIPT_PATH="$(realpath ./build-musl-cmake.sh)"
          CONTAINER_WORKDIR="/workspace"
          
          docker run --rm \
            -v "$HOST_SOURCE_DIR":"$CONTAINER_WORKDIR" \
            -v "$CMAKE_SCRIPT_PATH":/tmp/musl-build-cmake.sh \
            -w "$CONTAINER_WORKDIR" \
            "native-cmake" \
            /tmp/musl-build-cmake.sh

      - name: Build and Test C# with musl
        run: |
          docker run --rm \
            -v "$(pwd)":"$(pwd)" \
            -w "$(pwd)/native-schema-registry/csharp/AWSGsrSerDe" \
            mcr.microsoft.com/dotnet/sdk:8.0-alpine \
            sh -c "
              # First build - fails because protoc doesn't work with Alpine (musl libc based image)
              dotnet clean . && dotnet build . || true
              
              # Workaround because protoc from grpc.tools is not compatible with Alpine
              # This is only for the protoc compilation, and does not affect functionality of the library
              apk update && \
              apk --no-cache add libc6-compat && \
              apk --no-cache add \
              -X https://dl-cdn.alpinelinux.org/alpine/v3.17/main \
              -X https://dl-cdn.alpinelinux.org/alpine/v3.17/community \
              protobuf=3.21.9-r0 && \
              cd /root/.nuget/packages/grpc.tools/2.48.1/tools/linux_x64 && \
              rm protoc && \
              ln -s /usr/bin/protoc protoc && \
              chmod +x grpc_csharp_plugin && \
              cd /workspace/native-schema-registry/csharp/AWSGsrSerDe
              
              # Need to build it twice due to protobuf compilation misorder (normal for csharp builds today)
              dotnet build .
              
              # Only run unit tests as a part of the workflow
              dotnet test . --filter 'JsonSerializerTest | AvroSerializerTest | JsonDeserializerTest | AvroDeserializerTest | (ProtobufSerializerTest&FullyQualifiedName!~KafkaFlow) | (ProtobufDeserializerTest&FullyQualifiedName!~KafkaFlow)' --no-build
            "